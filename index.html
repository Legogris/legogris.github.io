<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Type-driven contract development</title>

    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Hakim El Hattab">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section style="text-align: left;">
          <h3>Type-driven contract development</h3>
          <p>
          <div style="line-height:70%;">
          <small>Jack Pettersson and Robert Edstr√∂m</small><br>
            <small>MSc thesis at Chalmers University of Technology, Sweden</small>
          </div>
          </p>
          <aside class="notes">
Hello everyone. My name is Robert, and I am currently working on my master's thesis together with Jack. We're working on a new programming language for the EVM. We're here to talk about how smart contracts are a perfect fit for a dependently typed functional languages and why we want to create this language targeting the EVM. We will walk you through a simple example illustrating a class of errors common among new contract developers and how an expressive type system can help.
          </aside>
        </section>

        <section>
          <h2>Motivations</h2>
          <ul>
            <li class="fragment">Catch bugs at compile time</li>
            <li class="fragment">What can be enforced using the type system?</li>
            <li class="fragment">Annotate types to generate boilerplate code</li>
            <li class="fragment">Functional paradigm</li>
          </ul>
          <aside class="notes">
Because of the way the Ethereum blockchain looks, there are some specific concerns for developers writing smart contracts. When deploying a smart contract to production, you want to be really sure that it behaves precisely as intended. An expressive type system could be a huge help here.
    We also want to give high-level abstractions of standard behaviour and common patterns for developers. Examples are boilerplate wrappers for error handling and cleanup and high-level cryptography functionality.
    Also, there has recently been research on the use of combinators in encoding financial contracts. A functional language that is more developer-friendly and high-level than LLL could therefore have its place in the ecosystem.
Jack will now present two types of errors that programmers make when they start developing smart contracts and how we can catch them at compile time.
          </aside>
        </section>
        <section>
          <section data-transition="slide-in fade-out">
          <h2>Case study:<br>Rock-paper-scissors</h2>
<p>A game of two players. Joining costs exactly 10 ether.</p>
          <pre class="fragment"><code class="hljs" data-trim contenteditable>
contract RPS {
  uint nPlayers;
  mapping (address => move) public moves;
  function addPlayer(uint move) returns (boolean success) {
    if (nPlayers < 2 && msg.value >= 10) {
      moves[msg.sender] = move;
      nPlayers++;

      return true;
    else {

      return false;
    }
  }
  //[...]
}
          </code></pre>
          <p class="fragment">Ether is not handled correctly!</p>
          <aside class="notes">
            Ok, so we look at a simple rock-paper-scissors game where each player pays 10 ether to join and the winner receives 20 ether. I think you all know the rules..?<br>
            <em>click</em><br>
            Here is a small example implementation of the function for players to join the game. It's very straight forward:
              <ul>
                <li>The game can only be joined if it isn't full.</li>
                <li>The player has to pay the fee.</li>
                <li>We save the player's move and address. The move is just 0, 1 or 2.</li>
              </ul>
            
            This seems quite reasonable, but there is actually a few bugs here. Can you see them?<br>
            
            What happens if a third player tries to join the game? <em>click</em> He loses all his ether, and there is no way to retrieve it! So let's fix this.
          </aside>
          </section>
          <section data-transition="fade-in fade-out">
          <h2>Case study:<br>Rock-paper-scissors</h2>
          <p>Amended version</p>
          <pre><code class="hljs" data-trim contenteditable>
contract RPS {
  uint nPlayers;
  mapping (address => uint) public moves;
  function addPlayer(uint move) returns (boolean success) {
    if (nPlayers < 2 && msg.value >= 10) {
      moves[msg.sender] = move;
      nPlayers++;
      msg.sender.send(msg.value - 10);
      return true;
    else {
      msg.sender.send(msg.value);
      return false;
    }
  }
  //[...]
}
          </code></pre>
                    <p class="fragment">Better, but the move is still revealed!</p>
          <aside class="notes">
            So this is better. But there is one problem left!<br>
            <em>click</em><br>
            Since the blockchain is transparent, the first player will reveal its move to the second player!
          </aside>
</section>
        </section>

        <section>
          <h2>Common errors</h2>
          <table>
            <thead>
              <tr>
                <th>Mistake</th>
                <th>Solution</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>No handling of ether</td>
                <td>Encode ether flow in the type system</td>
              </tr>
              <tr>
                <td>Openly communicating secret information</td>
                <td>Include crypto schemes in the language and stdlib</td>
              </tr>
              <!--
              <tr>
                <td>Incentive incompatibility</td>
                <td>?</td>
              </tr> -->
            </tbody>
          </table>

          <aside class="notes">
            Ok, so we have (at least) two classes of errors that are common for developers that are getting into smart contract development. What we are trying to do is to see if we can use en expressive type system to solve these.
          </aside>
        </section>


        <section>
          <section data-transition="slide-in fade-out" data-center="false">
            <h2>Catch errors using types</h2>
            <p>
              We start by including ether in the type signature:
            </p>
            <pre><code>
addPlayer : Int -> (success : Bool)
            { IN: value >= 10 }


            </pre></code>
            <ul>
            <li  class="fragment">Function is undefined for value < 10</li>
            </ul>

            <aside class="notes">
            Ok, so if we want to constrain the ether flow using the type system, what can we do? Well, we can start with including the transaction value in the type signature, like this.<br>
            <em>click</em><br>
            As you can see, we have also predicated the value, saying that this function requires at least 10 ether to run. Otherwise the transaction is invalid for our purposes, and any ether is returned to the sender.<br>

            This is certainly neat, but it doesn't solve our problems. But as you can see, we already know both the function's result and the transaction value. This is actually enough to specify how the function should handle the ether in all execution paths.
          </aside>

          </section>
          <section data-transition="fade-in fade-out" data-center="false">
            <h2>Catch errors using types</h2>
            <p>
              Describe ether flow:
            </p>
            <pre><code>
addPlayer : Int -> (success : Bool)
            { IN:   value >= 10;
              SEND: success ? value - 10 : value;
              SAVE: success ? 10         : 0 }
            </pre></code>
            <ul>
            <li>Function is undefined for value < 10</li>
            <li>saved+sent defined for all paths</li>
            <li class="fragment">Previous implementation wouldn't type check</li>
            </ul>

            <aside class="notes">
              We just take the return value and do a conditional check on it. <em>Point to the conditional check.</em> If the player <strong>was</strong> able to join the game, we should save 10 ether and send away the rest. If the player <strong>wasn't</strong> able to join the game, we should not save any ether and everything should be sent away.
              <em>click</em>
              Now, this type signature actually causes the problematic implementation to fail <strong>at compile-time</strong>. This is actually quite amazing, because we have catched a large class of bugs without any testing or formal verification whatsoever. This technique can actually be used to encode *any* contract behavior directly in the type signatures. But this requires some additional effort from the developer, and we will not go any deeper into this.

              But we still have the problem that the player's move is exposed to the opponent. The way to solve this is to use cryptographic commitments. What they allow you to do is to commit to a secret value and then reveal it at a later time. But developers shouldn't have to implement commitment schemes over and over. It is tedious and error-prone.
          </aside>
          </section>
          <section data-transition="fade-in slide-out">
            <h2>Catch errors using types</h2>
            <p>
              Hide player move
            </p>
            <pre><code>
addPlayer : Commit Int -> (success : Bool)
            { IN:   value >= 10;
              SEND: success ? value - 10 : value;
              SAVE: success ? 10         : 0 }
            </pre></code>
            <ul>
            <li>Commitments part of the language</li>
            <li class="fragment">Revealing function is generated at compile-time</li>
            <li class="fragment">Accessed using a library function:<pre><code>
open : Commit a -> a
            </code></pre></li>
            </ul>
            <aside class="notes">
              The way we solve this is by annotating the type of the move, to indicate that this value should be treated as a commitment. <em>click</em> The compiler will then automatically generate a function for the sender to reveal it. <em>click</em> When it has been revealed, it can be accessed in-code by using the "open" function from the standard library. It takes any commitment and returns the actual value. If the commitment has not been revealed when "open" is called, the transaction is invalid for our purposes and any ether is returned to the sender.
            </aside>
          </section>
        </section>
        <section>
          <h2>Type-correct implementation</h2>
          <pre><code class="Haskell">
addPlayer : Commit Int -> (success : Bool)
            { IN:   value >= 10;
              SEND: success ? value - 10 : value;
              SAVE: success ? 10         : 0 }
addPlayer {value} move = if !nPlayers < 2
                           then do save 10
                                   send (value-10) !sender
                                   -- save move
                                   -- increment counter
                                   return True
                           else do send value !sender
                                   return False   
          </pre></code>
        </section>
        <section>
          <h2>Implementation</h2>
          <h3>Language: Idris</h3>
          <ul>
            <li class="fragment">Very similar to Haskell, but...</li>
            <li class="fragment">Dependent types</li>
            <li class="fragment">Algebraic effects for environment interaction</li>
            <li class="fragment">Strictly evaluated</li>
          </ul>

          <aside class="notes">
            Ok, so how have we solved all this? Some of you might have noticed that the syntax we use is very similar to Haskell. We're using a language called Idris, which is inspired by Haskell but has dependent types and algebraic side-effects. This is what allows us to be so expressive in the type signatures.

            When we first started looking at this project, we just wanted to have something like Haskell on the blockchain. The more we looked at the problems, the more we realized that dependent types would be really neat. Lazy evaluation would also be prohibitively expensive to be useful in real life. The we found Idris. It's a recent research language that 
          </aside>

        </section>
        <section>
          <h2>Summary</h2>
<p>An expressive type-system can...
          <ul>
            <li>Catch large classes of errors at compile-time</li>
            <li>Generate boiler-plate code</li>
            <li>Provide compositionality</li>
          </ul>
</p>
          <aside class="notes">
            We have shown how dependent types and algebraic effects can be used in conjunction to define the flow of ether throughout the execution of a contract.
            We have also seen on a high level how type annotations can ensure that secret information does not become public until it is intended to.
            Finally, after listening to Lucius talk about compositionality, I hope you can see how this can be applied in smart contract development in a language like this. There has been a lot of research 
          </aside>
        </section>
        <section>
        <h2>Work in progress</h2>
         <ul>
         	<li>Lots of future work</li>
         	<li>Syntax and APIs in flux</li>
         </ul>
        </section>

        <section style="text-align: left;">
          <h1>THANK YOU</h1>
            <p>- Questions? </p>
            <p class="fragment"> - <a href="https://github.com/vindaloo-thesis/examples">https://github.com/vindaloo-thesis/examples</a> </p>
            <p class="fragment">- Feedback? Ideas? Talk to us! :)</p>
            <p class="fragment">- <a href="mailto:jack.pettersson@consensys.net">jack.pettersson@consensys.net</a>, <a href="mailto:robert@cacti.se">robert@cacti.se</a></p>
          </p>
        </section>

      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });

    </script>

  </body>
</html>
